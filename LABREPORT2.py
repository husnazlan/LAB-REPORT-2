# -*- coding: utf-8 -*-
"""Untitled13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gLCIbxpIfXgAfIhvQzrBQjLis3pebvEh
"""

import random

POPULATION_SIZE = 300
MAX_ONES = 50              # currently unused, but you could use it as a target
INDIVIDUAL_LENGTH = 80
MAX_FITNESS = INDIVIDUAL_LENGTH


# Define a class to represent an individual bit pattern
class Individual:
    def __init__(self, chromosome):
        self.chromosome = chromosome
        self.fitness = self.calculate_fitness()

    # Calculate the fitness of the individual as the number of ones
    def calculate_fitness(self):
        ones_count = 0
        for gene in self.chromosome:
            if gene == 1:
                ones_count += 1
        return ones_count


# Create a new individual with a random chromosome
def create_individual():
    chromosome = [random.randint(0, 1) for _ in range(INDIVIDUAL_LENGTH)]
    return Individual(chromosome)


# Create the initial population of individuals
def create_population():
    return [create_individual() for _ in range(POPULATION_SIZE)]


# Select the best individuals from the population for reproduction
def selection(population):
    # Sort the population by fitness in descending order
    sorted_population = sorted(population, key=lambda individual: individual.fitness, reverse=True)
    # Select the best 20% of individuals for reproduction
    return sorted_population[:int(0.2 * len(sorted_population))]


# Perform single-point crossover between two parent individuals
def crossover(parent1, parent2):
    # Choose a random crossover point
    crossover_point = random.randint(1, INDIVIDUAL_LENGTH - 1)

    # Create two new child chromosomes by combining the parent chromosomes
    child1_chromosome = parent1.chromosome[:crossover_point] + parent2.chromosome[crossover_point:]
    child2_chromosome = parent2.chromosome[:crossover_point] + parent1.chromosome[crossover_point:]

    # Create two new child individuals with the new chromosomes
    return Individual(child1_chromosome), Individual(child2_chromosome)


# Randomly flip a single bit in an individual's chromosome
def mutation(individual):
    gene_to_mutate = random.randint(0, INDIVIDUAL_LENGTH - 1)
    individual.chromosome[gene_to_mutate] = 1 - individual.chromosome[gene_to_mutate]
    individual.fitness = individual.calculate_fitness()


# Run the genetic algorithm for a fixed number of generations
def run_genetic_algorithm():
    # Create the initial population
    population = create_population()

    # Iterate through the specified number of generations
    for generation in range(50):
        # Select the best individuals for reproduction
        parents = selection(population)

        # Create a new population by reproducing and mutating the selected individuals
        new_population = []

        while len(new_population) < POPULATION_SIZE:
            parent1 = random.choice(parents)
            parent2 = random.choice(parents)
            child1, child2 = crossover(parent1, parent2)
            mutation(child1)
            mutation(child2)
            new_population.append(child1)
            if len(new_population) < POPULATION_SIZE:
                new_population.append(child2)

        # Replace the old population with the new one
        population = new_population

    # Return the best individual found
    return max(population, key=lambda individual: individual.fitness)


# Run the genetic algorithm and print the results
best_individual = run_genetic_algorithm()
print("Best individual: {}".format(best_individual.chromosome))
print("Fitness: {}".format(best_individual.fitness))

"""**1.2 Question 2**
1.2.1 Generate a bit pattern with predefined parameters from genetic algorithms:
1) Population set up is 300
2) The formula used in the preceding function reaches its maximum value when the
number of one equal to 50
3) The length of all individuals is 80
4) When the number of ones equals to 50, the return value would be 80
5) Number of generations is 50
"""

import random
from deap import base, creator, tools

# Evaluation function
def eval_func(individual):
    target_sum = 80
    # Fitness: higher when sum(individual) is closer to target_sum
    return len(individual) - abs(sum(individual) - target_sum),


# Create the toolbox with the right parameters
def create_toolbox(num_bits):
    # Only create classes once; avoid errors on re-import / rerun
    if not hasattr(creator, "FitnessMax"):
        creator.create("FitnessMax", base.Fitness, weights=(1.0,))
    if not hasattr(creator, "Individual"):
        creator.create("Individual", list, fitness=creator.FitnessMax)

    # Initialize the toolbox
    toolbox = base.Toolbox()

    # Generate attributes
    toolbox.register("attr_bool", random.randint, 0, 1)

    # Initialize structures
    toolbox.register("individual", tools.initRepeat, creator.Individual,
                     toolbox.attr_bool, num_bits)

    # Define the population to be a list of individuals
    toolbox.register("population", tools.initRepeat, list, toolbox.individual)

    # Register the evaluation operator
    toolbox.register("evaluate", eval_func)

    # Register the crossover operator
    toolbox.register("mate", tools.cxTwoPoint)

    # Register a mutation operator
    toolbox.register("mutate", tools.mutFlipBit, indpb=0.05)

    # Operator for selecting individuals for breeding
    toolbox.register("select", tools.selTournament, tournsize=3)

    return toolbox


if __name__ == "__main__":
    # Define the number of bits
    num_bits = 50

    # Create a toolbox using the above parameter
    toolbox = create_toolbox(num_bits)

    # Seed the random number generator
    random.seed(7)

    # Create an initial population of 300 individuals
    population = toolbox.population(n=300)

    # Define probabilities of crossing and mutating
    probab_crossing, probab_mutating = 0.5, 0.2

    # Define the number of generations
    num_generations = 50

    print("\nStarting the evolution process")

    # Evaluate the entire population
    fitnesses = list(map(toolbox.evaluate, population))
    for ind, fit in zip(population, fitnesses):
        ind.fitness.values = fit

    print("\nEvaluated", len(population), "individuals")

    # Iterate through generations
    for g in range(num_generations):
        print("\n===== Generation", g)

        # Select the next generation individuals
        offspring = toolbox.select(population, len(population))

        # Clone the selected individuals
        offspring = list(map(toolbox.clone, offspring))

        # Apply crossover on the offspring
        for child1, child2 in zip(offspring[::2], offspring[1::2]):
            # Cross two individuals
            if random.random() < probab_crossing:
                toolbox.mate(child1, child2)
                # "Forget" the fitness values of the children
                del child1.fitness.values
                del child2.fitness.values

        # Apply mutation
        for mutant in offspring:
            if random.random() < probab_mutating:
                toolbox.mutate(mutant)
                # "Forget" its fitness
                if hasattr(mutant.fitness, "values"):
                    del mutant.fitness.values

        # Evaluate individuals with an invalid fitness
        invalid_ind = [ind for ind in offspring if not ind.fitness.valid]
        fitnesses = list(map(toolbox.evaluate, invalid_ind))
        for ind, fit in zip(invalid_ind, fitnesses):
            ind.fitness.values = fit

        print("Evaluated", len(invalid_ind), "individuals")

        # The population is entirely replaced by the offspring
        population[:] = offspring

        # Gather all the fitnesses in one list and print the stats
        fits = [ind.fitness.values[0] for ind in population]
        length = len(population)
        mean = sum(fits) / length
        sum2 = sum(x * x for x in fits)
        std = abs(sum2 / length - mean ** 2) ** 0.5

        print("Min =", min(fits), ", Max =", max(fits))
        print("Average =", round(mean, 2), ", Standard deviation =", round(std, 2))

    print("\n==== End of evolution")
    best_ind = tools.selBest(population, 1)[0]
    print("\nBest individual:\n", best_ind)
    print("\nNumber of ones:", sum(best_ind))